#!/bin/bash

# gitversion inspects the current git state and calculates a semantic version number
# https://semver.org
# https://gitversion.net

MYNAME=$(basename $0)
VERSION_REGEXP="[-_.A-Za-z0-9]+"

# table of expression prefixes with filenames as keys,
# with the version string or regexp appended to the value
# as needed based on inquiry, set, or reset
declare -A prefix=(
	[README.yaml]="Version "
	[gradle.properties]="version="
	[src/main/groovy/net/venturechain/database/Connection.groovy]="GroovySQL "
	[src/main/groovy/net/venturechain/database/GroovySQL.groovy]="version "
	[tests/test.sh]="GROOVYSQL_VERSION="
)

function dump {
	for FILE in ${!prefix[*]} # returns the array keys
	do echo "in $FILE...looking for...'${prefix[$FILE]}$VERSION_REGEXP'"
	done
	exit
}

function usage { pod2usage -verbose 0 $MYNAME ; exit 1 ; }

function errexit { echo "ERROR: $*" ; exit 255 ; }

function get_version {
	STR="$1"
	FILE="$2"
	echo ">>> $FILE:"
	grep --line-number "$STR" $FILE
	echo
}

function set_version {
	OLD="$1"
	NEW="$2"
	FILE="$3"
	echo ">>> $FILE:"
	sed --in-place --regexp-extended "s/$OLD/$NEW/" $FILE
	grep --line-number "$NEW" $FILE # | sed 's/^/>>>> /'
	echo
}

function new_version {
	BRANCH=$(git branch --show-current)

	# easiest implementation requires that gitversion be run
	# at the top of the git work tree (where the .git folder is)
	if [[ -d .git ]]
	then NEWVERSION=$(gitversion -showvariable fullsemver 2>/dev/null)
	else errexit "no .git directory found"
	fi

	if [[ $NEWVERSION ]]
	then echo "new version will be $NEWVERSION [branch = $BRANCH]"; echo
	else errexit "gitversion did not return a version"
	fi
}

function update_version {
	# easiest implementation requires that gitversion be run
	# at the top of the git work tree (where the .git folder is)
	if [[ -d .git ]]
	then NEWVERSION=$(gitversion -showvariable fullsemver 2>/dev/null)
	else errexit "no .git directory found"
	fi

	if [[ $NEWVERSION ]]
	then echo "setting version to $NEWVERSION"; echo
	else errexit "gitversion did not return a version"
	fi

	for FILE in ${!prefix[*]} # returns the array keys
	do set_version "${prefix[$FILE]}$VERSION_REGEXP" "${prefix[$FILE]}$NEWVERSION" $FILE
	done
}

function reset_version {
	NEWVERSION=SEMANTIC_VERSION

	echo "setting version to $NEWVERSION"; echo

	for FILE in ${!prefix[*]} # returns the array keys
	do set_version "${prefix[$FILE]}$VERSION_REGEXP" "${prefix[$FILE]}$NEWVERSION" $FILE
	done
}

function current_version {
	for FILE in ${!prefix[*]} # returns the array keys
	do get_version "${prefix[$FILE]}" $FILE
	done
}

while getopts :hmMH OPT
do
	case $OPT in
	h)      pod2usage -verbose 1 $MYNAME ; exit 0 ;;
	m)      pod2usage -verbose 2 $MYNAME ; exit 0 ;;
	M)      pod2man --release="2.1" --center="Development Documentation" $MYNAME ; exit 0 ;;
	H)      pod2html --release="2.1" --center="Development Documentation" $MYNAME ; exit 0 ;;
	:)      echo "$MYNAME: Option $OPTARG requires a value" >&2; exit 2 ;;
	*)      usage;;
	esac
done
shift $(( OPTIND - 1 ))

case $1 in
current)	current_version ;;
update)		update_version ;;
reset)		reset_version ;;
new)		new_version ;;
dump)		dump ;;
*)		usage ;;
esac

exit

########################################

=head1 NAME

semantic_versioning.sh - manage semantic versioning

=head1 SYNOPSIS

    semantic_versioning.sh [-hm] { current | update | reset | new }

=head1 DESCRIPTION

Provides semantic versioning implementation.

See L<https://semver.org> and L<https://gitversion.net> for background and more information.

Intended usage is that all version references use the string "SEMANTIC_VERSION" as a placeholder
for the generated version string.
This placeholder can appear anywhere such as in quoted strings or comments.
The update operation does a simple regex string replacement of the placeholder with the newly
generated semantic version string generated by C<gitversion> based on the current git state.

The development flow assumes that whenever compilation and/or packaging occurs,
the git work tree is first updated with C<semantic_versioning.sh update> which replaces
the placeholder with the newly generated semantic version string.
Then the compilation and/or packaging takes place.
And finally the version string is reset with C<semantic_versioning.sh reset>.
Basically it just backs out the version string to the placeholder "SEMANTIC_VERSION".

Step-wise the flow looks like,

=over 4

=item 1. git checkout desired branch (main, develop, feature, release, etc)

Work tree contains files with placeholder version strings.

=item 2. semantic_versioning.sh update

Work tree contains files with semantically updated version strings (uncommitted).

=item 3. compilation and/or packaging

Binaries and packages contain version-stamped files.

=item 4. semantic_versioning.sh reset

Work tree (again) contains files with placeholder version strings.
Git no longer identifies any files as uncommitted since they are back to their original state.

=back

=head1 OPTIONS

=over 4

=item -h

Display this help information.

=back

=head1 EXAMPLES

To display the new version that will be generated,

    semantic_versioning.sh new

To display the current version,

    semantic_versioning.sh current

To update the current work tree with the new version,

    semantic_versioning.sh update

To reset the current work tree back to its unversioned state,

    semantic_versioning.sh reset

